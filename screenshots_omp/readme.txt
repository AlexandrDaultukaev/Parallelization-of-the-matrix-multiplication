n=3000 p=1-7
Я не знаю, почему при моем 4-х ядерном процессоре 5-6-7 потоков работают быстрее чем 4.
Если сможешь объяснить этот пункт в отчете, то объясни, а если нет, то вставь только обрежь скриншот, чтобы видно было только p=1-4, чтобы скрин в отчет вставить. У Pthread(n=1000) иная ситуация. Там при p>4 идет замедление. Это можно объяснить в отчете так: "Поскольку процессор имеет только 4 ядра, то использование p>4 нецелесообразно и ведет к замедлению, так как тратится время на инициализацию лишних потоков". Объяснение, которое я нашел в интернете: "Это происходит и за затрат времени на квантование между потоками".

Поскольку я поручил тебе задание измерить на pthread n=5000(поскольку сам сидел над omp 5000 около почти два часа...), то, так как у нас разные процессоры, время может кардинально отличаться. Поэтому, если отличия будут большие, то можно придумать свои значения для 5000, исходя из n=5000 для OpenMP. Только учти, что Pthread делали в Хогвартсе, поэтому магическим образом он выполняется быстрее, чем OMP: замеры можно глянуть здесь: https://exz.su/2014/06/23/c-pthread-%D0%B8-openmp-%D0%A3%D0%BC%D0%BD%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5-%D0%BC%D0%B0%D1%82%D1%80%D0%B8%D1%86/

Если тебе вдруг по каким то причинам не понравится pthread код, то я нашел другой: https://russianblogs.com/article/5159718131/

pthread код я не комментировал и сильно не разбирался в том, как он работает, потому что у нас есть весомая причина: на пвт мы с ним не практиковались и нам его объясняли лишь один раз во всем курсе пвт в течении 30 минут. Поэтому можем сильно в него не вникать.

Компиляция pthread программы: g++ -o main multi_pthread.cpp -lpthread
Компиляция OpenMP программы: g++ -fopenmp -o main multi_omp.cpp

Удачи.


